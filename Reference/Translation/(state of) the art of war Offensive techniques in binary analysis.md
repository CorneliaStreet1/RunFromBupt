### II. AUTOMATED BINARY ANALYSIS

多年来，研究人员一直在努力开发自动二进制分析技术。然而，尽管这一领域最近取得了一些进展，但在现实世界中开发和部署此类系统仍具有挑战性。这是因为，根据相关技术的不同，要对现实世界中的软件进行自动分析，必须克服一些严重的限制。在本节中，我们将探讨自动分析所面临的挑战，并讨论为什么 DARPA 网络大挑战竞赛可以为比较不同的分析方法提供有意义的途径。

*A. Trade-offs*

不难理解为什么二进制分析具有挑战性：从某种意义上说，问 "会崩溃吗？"类似于问 "会停止吗？"，而任何此类分析很快就会触犯停止问题[32]。程序分析，尤其是进攻性二进制分析，往往以谨慎平衡的理论权衡为指导，以保持可行性。必须进行这种权衡的领域主要有两个：  



可重复性。错误并不都是一样的。根据系统所做的权衡，特定分析发现的错误可能无法重放。这可以归结为分析的操作范围。有些分析会从头开始执行整个应用程序，这样它们就能推理出触发漏洞到底需要做什么。其他系统则分析应用程序的各个部分：它们可能会在特定模块中发现漏洞，但无法推理出如何触发该模块的执行，因此无法自动重放崩溃。
语义洞察。有些分析缺乏以语义方式推理程序的能力。例如，动态分析可能能够跟踪应用程序执行的代码，但却无法理解执行代码的原因，或输入的哪些部分导致应用程序以特定方式运行。另一方面，如果符号分析能确定导致某些程序行为的特定字节输入，那么它的语义理解能力就会更强。



为了提供输入的可重放性或语义理解，分析技术必须做出一定的权衡。例如，高重放性与低覆盖率相关。这是很直观的：因为产生可重放输入的分析技术必须了解如何接触到它想要分析的任何代码，因此它将无法像不产生可重放输入的分析技术那样分析那么多代码。另一方面，如果不能重放触发输入以验证漏洞，那么不优先考虑漏洞重放性的分析就会出现大量误报（即不代表实际漏洞的缺陷检测）。在没有可重放输入的情况下，这些误报必须通过启发式方法进行过滤，这反过来又会带来误报。同样，为了深入了解被分析程序的语义，分析必须存储和处理大量数据。例如，具有语义洞察力的动态分析可能会存储程序特定分支必须满足的条件。另一方面，静态分析通过所选的数据域来调整语义洞察力--较简单的数据域（即通过跟踪范围而非实际值）所代表的语义洞察力较低。



试图同时实现可重复性和高度语义理解的分析会遇到可扩展性问题。保留整个应用程序的语义信息（从入口点到可能采取的所有操作）需要的处理能力在概念上与在所有可能情况下执行程序所需的资源完全相同。在所有可能条件下执行程序所需的资源。这样的分析无法扩展，而且为了适用，必须舍弃信息并牺牲合理性、 必须舍弃信息，牺牲稳健性（即 保证发现所有潜在漏洞）



除了这些基本挑战，还有实施实现的挑战。其中最大的挑战是环境建模。任何具有高度语义理解能力的分析都必须对应用程序与其环境的交互进行建模。在现代操作系统中，这种交互复杂得令人难以置信。例如，现代版本的 Linux 包含三百多个系统调用，要使分析系统完整，就必须对所有这些调用的影响进行建模。



**Example**：为了展示二进制分析所面临的各种挑战，我们在*List 1*中提供了一个存在多个漏洞的程序的具体示例。出于清晰和篇幅的考虑，本示例进行了简化，其目的只是让读者了解 本文稍后将讨论的观点。

观察对 memcpy 的三次调用：第 10 行和第 30 行的调用会导致缓冲区溢出，而第 16 行的调用不会。然而，根据所跟踪的信息量，静态分析技术可能会将对 memcpy 的三次调用都报告为潜在错误，包括第 16 行的调用，因为它没有足够的信息来确定不可能发生缓冲区溢出。此外，虽然静态分析报告会包括这些错误的位置，但不会提供触发这些错误的输入信息。

动态技术（如模糊测试）的好处是可以创建可操作的输入，从而触发任何已发现的漏洞。另一方面，简单的模糊技术通常只能发现浅层次的漏洞，无法通过需要精确输入的代码。在*List1*中，动态技术很难发现第 10 行的错误，因为它需要特定的输入才能满足条件。然而，由于第 30 行的溢出可以通过随机测试触发，模糊测试技术应该能够找到触发错误的输入。

为了找到第 10 行的错误，我们可以引入一个抽象数据模型来同时推理许多可能的输入。动态符号执行（DSE）就是这样一种方法。然而，动态符号技术虽然功能强大，却存在 "路径爆炸问题"，即路径数量会随着每个分支呈指数增长，很快就会变得难以处理。符号执行将检测到第 10 行的错误，并使用约束求解器为其生成输入。此外，它还能证明第 16 行的 memcpy 不能溢出。然而，执行很可能无法发现第 30 行的错误，因为有太多的潜在路径不会触发错误。

```c
int main(void) {
    char buf[32];
    
    char *data = read_string();
    unsigned int magic = read_number();
    
    // difficult check for fuzzing
    if (magic == 0x31337987) {
        // buffer overflow
        memcpy(buf, data, 100);
    }
    
    if (magic < 100 && magic % 15 == 2 &&
        magic % 11 == 6) {
        // Only solution is 17; safe
        memcpy(buf, data, magic);
    }
    
    // Symbolic execution will suffer from
    // path explosion
    int count = 0;
    for (int i = 0; i < 100; i++) {
        if (data[i] == ’Z’) {
            count++;
        }
    }
    
    if (count >= 8 && count <= 16) {
        // buffer overflow
        memcpy(buf, data, count*20);
    }
    
    return 0;
}
```

*B. The DARPA Cyber Grand Challenge*

2013 年 10 月，DARPA 宣布举办 "DARPA 网络大挑战(Cyber Grand Challenge, CGC)"[23]。与其他领域的 DARPA 大挑战赛（如机器人和自动驾驶汽车）一样，CGC 让来自世界各地的团队相互竞争，所有参赛者都必须是自主程序。参赛者在网络大挑战赛中的目标直截了当：他们的系统必须自主识别、利用和修补所提供软件中的漏洞。数百万美元的奖金已经公布：完成 CGC 资格赛（2015 年 6 月举行）的前 7 支队伍将获得 75 万美元奖金，CGC 决赛（2016 年 8 月举行）的前 3 支队伍将分别获得 200 万美元、100 万美元和 75 万美元奖金。

为了解决环境建模问题，他们专门为 CGC 创建了一个新的操作系统：DECREE 操作系统。DECREE 是一个极其简单的操作系统，只有 7 个系统调用：发送、接收和 waitfd 用于通过文件描述符发送、接收和等待数据；random 用于生成随机数据；allocate 和 deallocate 用于内存管理；termininate 用于退出、 以及终止退出。

尽管环境模型很简单，但 DARPA 为 CGC 提供的二进制文件的复杂程度范围却很宽。它们的大小从 4 千字节到 10 兆字节不等，实现的功能从简单的echo服务器到网络服务器，再到图像处理库。到目前为止，DARPA 已将比赛中使用的所有二进制文件开源，其中包括概念验证漏洞 和有关漏洞的文章[24]。由于简单的环境模型使得准确实施和评估（大规模）二进制分析技术变得可行，所以我们在本文中使用 DARPA CGC 样本作为比较评估的数据集。



*C. Comparative Analysis of CGC Binaries*

攻击性二进制分析使用不同的基础技术来推理正在处理的应用程序。例如，它们可以分析不同领域的数据，或利用与被测应用的不同交互级别。在接下来的两节中，我们将对目前的技术现状进行调查，并选择几种分析方法进行深入评估。我们特别关注以识别和利用二进制软件缺陷为目标的分析（例如，利用符号执行识别内存安全违规），而不是这些分析所基于的更一般的二进制分析技术（在这种情况下，符号执行本身）。

### III. BACKGROUND: STATIC VULNERABILITY DISCOVERY

静态技术是在不执行程序的情况下对程序进行推理。通常，程序是在一个抽象域上解释的。包含 1 和 0 位的内存位置包含其他抽象实体（在熟悉的一端，这可能只是整数，但正如我们在下文中解释的，这些实体可能包含更多抽象结构）。此外，诸如内存布局，甚至执行路径等程序结构也可能被抽象化。

在此，我们将静态分析分为两种范式：将程序属性建模为图形（即控制流图形）的范式和将数据本身建模的范式。

静态漏洞识别技术有两个主要缺点，与第 II-A 节讨论的权衡有关（见上一节的TradeOffs）。首先，结果不可重放：静态分析的检测结果必须手工验证，因为关于如何触发检测到的漏洞的信息无法恢复。其次，这些分析倾向于在较简单的数据域上运行，从而降低了其语义洞察力。简而言之，这些分析过于近似：虽然它们往往能权威地推理出某些程序属性（如漏洞）的不存在，但在陈述漏洞的存在时，它们的误报率很高。



*A. Recovering Control Flow*

控制流图（CFG）中的节点是基本指令块，边是它们之间可能的控制流传输，恢复控制流图几乎是所有漏洞发现静态技术的先决条件。文献 [21]、[33]、[34]、[50]、[58]、[59] 广泛讨论了控制流恢复问题。CFG 恢复是以递归算法的形式实现的，该算法拆解并分析一个基本块（如 Ba），识别其可能的出口（即一些后继基本块，如 Bb 和 Bc）并将其添加到 CFG 中（如果尚未添加的话），将 Ba 连接到 Bb 和 Bc，并对 Bb 和 Bc 重复进行递归分析，直到识别不出新的出口为止。CFG 恢复有一个基本挑战：间接跳转。当二进制程序将控制流转移到寄存器或内存位置中的值所代表的目标时，就会发生间接跳转。与直接跳转不同的是，直接跳转的目标值被编码到指令本身，因此是可以轻易解决的，而间接跳转的目标值则会因多种因素而变化。具体来说，间接跳转可分为以下几类：

1. 计算跳转。计算跳转的目标由应用程序通过执行代码指定的计算来确定。这种计算可以进一步依赖其他寄存器或内存中的值。一个常见的例子是跳转表：应用程序使用寄存器或内存中的值确定存储在内存中的跳转表的索引，从该索引中读取目标地址，然后跳转到该地址。
2. 上下文敏感的跳转。间接跳转可能取决于应用程序的上下文。常见的例子是标准 C 语言库中的 qsort()--该函数接收一个回调函数，用于比较传入的值。因此，qsort() 内一些基本模块的跳转目标取决于其调用者，因为调用者提供了回调函数。
3. 对象敏感的跳转。这一类跳转是第二类的一种特殊情况。在面向对象的语言中，对象的多态性要求使用虚函数，而虚函数通常是以函数指针虚拟表的形式实现的，在运行时，我们会查阅这些虚拟表来确定跳转目标。因此，跳转目标取决于调用者（作为参数）传递给函数的对象类型

我们设计了不同的技术来处理不同类型的间接跳转，我们将在第七部分讨论其中几种技术的实现。归根结底，CFG 恢复的目标是尽可能多地解析这些间接跳转的目标，从而创建 CFG。给定的间接跳转可能会解析到一组值（即跳转表中的所有地址，如果有条件可以触发这些地址的使用），这组值可能会根据对象和上下文的敏感性发生变化。根据跳转目标的解析程度，CFG 恢复分析具有两种特性：

1. **准确性（Soundness）**：如果CFG恢复技术在生成的图中代表了所有潜在的控制流转移，那么它就是准确的。也就是说，当一个间接跳转被解析为它实际可以指向的地址的子集时（也就是你解析漏了情况），图的准确性就降低了。如果一个基本块的潜在目标被忽略，那么该块的目标可能永远不会被CFG恢复算法看到，而且该块所进行的任何直接和间接跳转也会被忽略。这具有累积效应：未被解析的一个间接跳转可能严重降低图的完整性。准确性可以被看作是二进制中间间接跳转目标识别的真阳性概率（true positive rate）。
2. **完整性（Completeness）**：完整的CFG恢复构建了一个CFG，其中所有的边都代表实际可能的控制流转移。如果CFG分析在完整性方面出现错误，它可能包含实际上在实践中不可能存在的边。完整性可以被看作是间接跳转目标识别的假阳性率（false positive rate）的倒数。

如果 CFG 恢复分析生成的图是空的，则认为是完整的（complete）；如果分析生成的图中每条指令都指向其他指令，则认为是合理的（sound）。 虽然理想状态介于两者之间，但这很难通过可扩展算法实现。因此，不同的分析需要在两者之间做出不同的妥协。
控制流图的另一个难点是精确测量代码覆盖率，即控制流图发现了多少代码。由于存在死代码（任何跳转都无法到达的代码），这通常会变得复杂。



*B. Vulnerability Detection with Flow Modeling*

通过分析程序属性图，可以发现程序中的某些漏洞。
基于图的漏洞发现。程序属性图（如控制流图、数据流图和控制依赖图）可用于发现软件中的漏洞。相关技术最初应用于源代码 [60]、[61]，后来扩展到二进制文件 [45]。这些技术依赖于建立一个Bug的模型（由控制流图或数据依赖图中的一组节点表示），并在应用程序中识别该模型的出现。不过，这些技术的目标是搜索易受攻击代码的副本，从而使这些技术从对已存在的漏洞的知识中获益。与这些技术不同，本文的重点是发现全新的漏洞。



*C. Vulnerability Detection with Data Modeling*

静态分析还可以对应用程序运行所依据的数据抽象进行推理。
值集分析。一种常见的静态分析方法是值集分析（VSA）[6]。从高层次上讲，VSA 试图在程序中的任意给定点确定程序状态（即内存和寄存器中的值）的严密近似值。这可用于了解间接跳转的可能目标或内存写入操作的可能目标。虽然这些近似值缺乏准确性，但它们是合理的。也就是说，它们可能过度近似，但绝不会低估。
通过分析内存读写的近似访问模式，可以在二进制文件中确定变量和缓冲区的位置。完成这项工作后，就可以对恢复的变量和缓冲区位置进行分析，找出重叠的缓冲区。这种重叠缓冲区可能是缓冲区溢出漏洞等造成的，因此每次检测都是一个潜在漏洞。

### IV. BACKGROUND: DYNAMIC VULNERABILITY DISCOVERY

动态方法是在实际或仿真环境中，根据特定输入检查程序执行情况的分析方法。在本节中，我们将特别关注用于识别漏洞的动态技术，而不是作为其基础的一般二进制分析技术。
动态技术分为两大类：具体执行和符号执行。这些技术产生的输入具有很强的可重放性，但在语义洞察力方面各有不同。

> "Concrete execution"（具体执行）是指在实际或模拟环境中，针对特定输入运行程序并分析其实际执行过程的方法。在具体执行中，程序在给定具体输入的情况下被执行，分析的是实际的程序行为。这种方法实际运行程序，观察其在具体输入下的行为，可以提供详细的执行信息，包括具体的变量值、路径等。Concrete execution是一种动态分析方法，与静态分析方法不同，它关注的是程序的运行时行为，而不是仅仅依赖于程序的静态代码。
>
> 在动态分析技术中，具体执行和符号执行（symbolic execution）是两个主要的子类。在具体执行中，程序在实际输入下执行，产生实际的输出和行为。与之相反，符号执行是一种在程序的输入和其他变量上进行符号推导的技术，不依赖于具体的输入值，而是使用符号来表示变量的值，从而能够在不具体运行程序的情况下进行路径探索和分析。
>
> 这两种方法各有优势：具体执行提供了实际的运行结果，但可能无法覆盖所有可能的输入情况；而符号执行可以探索多个输入情况，但由于路径爆炸（path explosion）的问题，可能会导致分析过程变得非常复杂和耗时。

*A. Dynamic Concrete Execution*

动态具体执行的概念是在最小仪器化（）的环境中执行程序。程序像正常程序一样运行，处理与正常程序相同的数据域（即 1 和 0）。这些分析通常是在单一路径的层面上进行推理（即 "当给定这个特定输入时，程序会采取什么路径"）。因此，动态具体执行需要用户提供测试用例。这是一个问题，因为对于大型或未知数据集（如我们的数据集）来说，这样的测试用例并不容易获得

> "Minimally-instrumented"（最小仪器化）指的是在执行程序时，尽量减少对程序进行修改或插入额外代码的情况。在动态具体执行中，程序在最小仪器化环境下运行，意味着尽可能保持程序的原始状态，不对其进行大幅度的修改或添加额外的代码。

1) **Fuzzing（模糊测试）**： 动态具体执行与漏洞发现最相关的应用是模糊测试。模糊测试是一种动态技术，它向应用程序提供畸形输入，试图引发程序崩溃。最初，这种输入由硬编码规则生成，并提供给应用程序，很少对执行情况进行深入监控[38]。如果应用程序在收到特定输入时崩溃，则认为该输入触发了Bug。否则，输入将进一步随机变异。遗憾的是，模糊器受到测试用例要求的限制。如果没有精心构造的测试用例来进行变异，模糊测试器很难测试除程序最表面功能以外的其他功能。

基于覆盖范围的模糊测试（**Coverage-based fuzzing**，覆盖率导向的模糊测试）。 基于代码覆盖的模糊测试的出现，部分缓解了对精心制作的测试用例的要求[39]。基于代码覆盖范围的模糊测试器试图生成最大化目标应用中执行代码量的输入（也就是构造输入，使得尽量多的代码会被执行），因为执行的代码越多，执行易受攻击代码的几率就越大。American Fuzzy Lop（AFL）[1]是一种最先进的模糊测试器，最近发现了许多漏洞，它使用代码覆盖率指标作为唯一的指导原则，它在发现漏洞方面的成功推动了近年来对模糊测试技术兴趣的增长。
基于覆盖率的模糊测试缺乏对目标应用的语义洞察。这意味着，虽然它能检测到某段代码尚未被执行，但它无法理解输入的哪些部分需要改变才能使得代码被执行。

基于污点的模糊测试（**Taint-based fuzzing，污点感知的模糊测试**）。改进模糊测试的另一种方法是开发基于污点的模糊测试器 [9], [62]。这类模糊测试器分析应用程序如何处理输入，以了解在未来运行中应修改输入的哪些部分。其中一些模糊测试器将污点跟踪与数据依赖恢复等静态技术相结合 [30], [42]。还有一些模糊测试器引入了协议分析工作，以提高模糊覆盖率[22]。
虽然基于污点的模糊测试器可以理解输入的哪些部分应该被改变，以驱动程序沿着指定路径执行，但它仍然不知道如何改变这些输入。



2. 动态符号执行（*Dynamic Symbolic Execution*）： 符号技术弥补了静态分析和动态分析之间的差距，并提供了一种解决方案，以应对模糊分析在语义方面的有限洞察力。动态符号执行是符号执行的一个子集，是一种动态技术，因为它在仿真环境中执行程序。不过，这种执行发生在*抽象*域的*符号变量*中。当这些系统模拟应用程序时，它们会在整个程序执行过程中跟踪寄存器和内存的状态，以及这些变量的*约束条件*。每当执行到一个条件分支时，执行就会分叉，并沿着*两条*路径进行，将分支条件保存为分支路径上的约束条件，并将分支条件的反向（取逻辑非）为不执行分支路径上的约束条件[49]。

与模糊处理不同，动态符号执行对目标应用程序具有极高的语义洞察力：当正在执行的路径之一触发了分析所感兴趣的条件时，此类技术可以通过使用累积的路径约束从而反向构造一个适当的输入，来推理如何触发特定的预期程序状态。 这使它成为识别软件Bug的一个极其强大的工具，因此，动态符号执行是一个非常活跃的研究领域。

> such techniques can reason about how to trigger specific desired program states by using the accumulated path constraints to retroactively produce a proper input to the application when one of the paths being executed has triggered a condition in which the analysis is interested.

经典的动态符号执行（**Classical dynamic symbolic execution.**）。动态符号执行可直接用于查找软件中的漏洞。动态符号执行最初应用于源代码测试[12][13]，后来被 Mayhem[16] 和 S2E[19] 扩展到二进制代码。这些引擎通过执行路径探索来分析应用程序，直到发现漏洞状态（例如，指令指针被攻击者的输入覆盖）。

然而，第 II-A 节中讨论的权衡问题开始发挥作用：由于存在路径爆炸问题，目前提出的所有符号执行技术的可扩展性都非常有限：因为每个分支都可以创建新的路径，程序中的路径数量会随着每个路径中分支指令的数量呈指数增长。有人尝试通过优先处理有希望的路径 [11]、[37] 以及在适当的情况下合并路径 [5]、[35]、[47] 来解决路径爆炸问题。然而，总体而言，纯动态符号执行分析引擎尚未克服这一挑战，而且（正如我们在本文后面所展示的），此类系统发现的大多数错误都是浅层次的。

符号辅助模糊测试（**Symbolic-assisted fuzzing**）。解决路径爆炸问题的一种建议方法是将大部分处理工作卸载给更快的技术，如模糊处理。这种方法利用了模糊处理的优势（即速度），并试图减轻其主要弱点（即缺乏对应用的语义洞察力）。因此，研究人员将模糊处理与符号执行配对使用 [14]、[15]、[17]、[28]、[29]、[54]。这种符号引导模糊测试器通过在动态符号执行引擎中处理模糊测试组件识别出的输入，对其进行修改。动态符号执行利用对所分析程序的更深入了解来适当改变输入，提供额外的测试用例，触发以前未探索过的代码，让模糊组件继续取得进展（即在代码覆盖率方面）。

欠约束符号执行（**Under-constrained symbolic execution**）。提高动态符号执行可操作性的另一种方法是只执行应用程序的一部分。这种方法被称为 "欠约束符号执行"[26], [46]，可有效识别潜在的错误，但有两个缺点。首先，它无法确保执行应用程序部分内容时有适当的上下文，从而导致结果中出现许多假阳性。其次，与静态漏洞发现技术类似，受限符号执行放弃了所发现漏洞的可重放性，以换取可扩展性。

### V. BACKGROUND: EXPLOITATION

漏洞发现分析实际上是发现崩溃输入。对这些崩溃输入进行分类诊断——即了解哪些崩溃代表实际的安全问题——超出了大多数此类方法的范围。不过，确实有一些工作涉及对发现的漏洞进行再现和分析。在本节中，我们将介绍重现已发现的崩溃、自动生成漏洞利用程序以验证崩溃的安全影响，以及加固漏洞利用程序使其在现代缓解技术面前具有弹性的过程（意思就是把这个流程介绍一遍）。



*A. Crash Reproduction*

大多数漏洞发现分析都是在不太真实的条件下执行测试应用程序的。例如，许多模糊器会去随机化执行。也就是说，它们会硬编码任何随机性来源，如可执行文件的 PID、当前时间等。这样做主要有两个原因。首先，在大多数现代模糊处理方法中，都有一个隐含的假设，即向应用程序的两个实例提供相同的输入，两次都会产生相同的结果。其次，其他技术（如动态符号执行）中的随机性建模并不是一个探索完善（Well-explored）的研究领域。
由于去随机化，漏洞发现技术所报告的崩溃可能无法在分析环境之外进行重放。考虑这样一种情况：应用程序会生成一个随机令牌，并要求用户在进入不安全代码段和崩溃前提供该令牌。在去随机化的分析环境中，生成的令牌将始终具有相同的值，分析确定的崩溃输入将始终采用相同的路径，从而导致崩溃。然而，在分析环境之外，令牌总是不同的，先前崩溃的输入可能会采取非崩溃路径。
不可重放的崩溃输入一般分为两类。
缺失数据。漏洞发现技术有时可以 "猜测 "出正确的响应值，而无需首先从应用程序中获取这些值。在我们的示例中，令牌在去随机化环境中始终是一个常量值，而模糊器等分析引擎可能会在未从程序中获取该值的情况下意外猜到它。在分析环境之外重放由此产生的崩溃输入时，令牌值将不会匹配，崩溃也不会发生。
关系缺失。语义洞察力较低的技术（如模糊测试）无法恢复从程序中获取的数据与随后提供给程序的数据之间的关系。在我们的示例中，尽管崩溃输入可能会导致应用程序向用户提供令牌，以便随后用于导致崩溃，但模糊器的输出缺乏应用程序向用户提供的令牌值与用户必须向应用程序提供的令牌值之间的关系。

在数据缺失的情况下，输入在分析环境之外根本无法重放，而且可能会发现新的崩溃输入。目前已有专门识别数据泄露的分析方法[42]，但我们尚未在 angr 中实现此类分析。
在后一种情况下，必须将去随机化的崩溃输入转换为输入规范，该规范根据从应用程序接收的数据与随后提供给应用程序的数据之间的关系，定义如何与应用程序通信。Replayer [43]就是这样一种方法，它通过计算程序路径上的先决条件，了解如何在真实世界条件下重现程序路径。



*B. Exploit Generation*

利用上述一种或多种方法的高产漏洞挖掘引擎，可能会为测试过的应用程序产生许多崩溃。然而，并非所有这些崩溃都是可利用的。NULL 指针解引用就是不可利用输入的一个例子。由于现代操作系统不允许在地址 0 处映射内存，因此这些以前可被利用的情况已沦落为不可被利用的崩溃。了解崩溃是否可被利用有助于分类诊断错误（即了解哪些错误应首先调查和修复）。
测试崩溃是否可被利用的明显方法是尝试利用它。为此，有人提出了几种系统，试图接收崩溃输入，并自动将其转换为应用程序的漏洞利用[4]、[31]、[51]。



*C. Exploit Hardening*

近年来，二进制加固技术（如不可执行堆栈区域和地址空间布局随机化（ASLR））严重降低了传统漏洞（如第一代自动漏洞利用引擎生成的漏洞）的有效性。因此，即使是可利用的漏洞，也可能通过现代保护措施得到缓解。
当前的自动利用技术是在现代缓解技术广泛应用之前设计的，而现代软件保护使其产生的漏洞利用无法发挥作用。为了规避这一问题，人们创造了一些方法，以自动加固使用当前技术生成的漏洞利用程序，使其免受此类防御措施的影响。这些技术的工作原理是将传统的、基于shellcode的漏洞利用程序转换为等效的利用面向返回编程（Return-Oriented Programming）[52]的漏洞利用程序。因此，需要一种自动方法来构建面向返回的程序，目前已开发出几种这样的方法[18]、[48]。

### VI. ANALYSIS ENGINE

我们在第三、四和五节中介绍的分析方法是在过去几年的不同时间提出的，采用了不同的技术实现，并以不同的方法在不同的数据集上进行了评估。这很成问题，因为我们很难了解不同方法的相对有效性及其对不同类型应用的适用性。
为了缓解这一问题，我们开发了一个灵活、功能强大的下一代二进制分析系统 angr，并用它实现了前几节中介绍的部分分析。本节将介绍该分析系统、我们的设计目标以及该设计对现实二进制文件分析的影响。



*A. Design Goals*

我们对 angr 的设计目标如下：
跨体系结构支持。随着通常运行 ARM 和 MIPS 处理器的嵌入式设备的兴起，现代软件需要针对不同的硬件架构编写。这与前十年的情况不同，当时大多数分析引擎只需支持 x86 即可：现代二进制分析引擎必须能够执行跨体系结构分析。此外，32 位处理器不再是标准；现代分析引擎必须支持 64 位二进制文件的分析。
跨平台支持。与跨体系结构支持类似，现代分析系统必须能够分析来自不同操作系统的软件。这意味着必须抽象出各个操作系统特有的概念，并且对于加载不同的可执行文件格式的支持必须实现。
支持不同的分析范式。一个有用的分析引擎必须支持前面章节中描述的各种分析。这就要求引擎本身进行抽象，并提供不同类型的内存模型和数据域。
可用性。angr 的目的是为安全社区提供一个工具，用于复现、改进和创建二进制分析技术。因此，我们努力保持 angr 较低的学习曲线和较高的可用性。angr 几乎完全是用 Python 实现的，其 API 简洁明了，可以通过 IPython 交互式 shell [44] 轻松使用。虽然选择 Python 可能会导致性能在常数时间上低于其他可能的语言，但大多数二进制分析技术都存在算法缓慢的问题，因此很少能感受到语言本身对性能的影响。当语言开销很重要时，angr 可以在 Python JIT 引擎 PyPy 中运行，从而显著提高速度。

我们的目标是让 angr 在一周内就能在我们的平台上重现典型的二进制分析技术。事实上，我们能够在八天内重现 Veritesting [5]，一个月内重现引导符号执行，一个周末内重现 AEG [4]，大约三周内重现 Q [48]，两天内重现欠约束符号执行 [46]。我们很难估算出动态符号执行和值集分析的实现工作量，因为我们是在两年多的时间里在构建系统的同时实现这两项工作的。
为了实现这些设计目标，我们必须精心构建我们的分析引擎。为此，我们为各种分析创建了一系列模块化构件，并注意保持它们之间的严格分离，以减少 angr 高层部分（如状态表示）对低层部分（如数据模型）的假设数量。这样，我们就能更方便地在分析之间进行混合和转换。我们希望这也能让其他研究人员更容易重复使用 angr 的各个模块。在接下来的几节中，我们将讨论每个 angr 子模块的技术设计。



*B. Submodule: Intermediate Representation*

为了支持多种体系结构，我们将特定体系结构的本地二进制代码转换为中间表示（IR），并在此基础上实现分析。我们没有编写自己的 "IR 提升器（IR lifter）"（这是一项极其耗时的工程），而是利用了 Valgrind 项目的 libVEX（IR 提升器）。libVEX 生成的 IR 称为 VEX，专门用于程序分析。我们使用最初为 Firmalice 编写的 PyVEX [53]，将 VEX IR 暴露到 Python 中。利用 VEX，我们可以为 32 位和 64 位版本的 ARM、MIPS、PPC 和 x86（后者的 64 位版本为 amd64）处理器提供分析支持。Valgrind 的贡献者们还在不断改进，例如，目前正在进行 SPARC 架构的移植。正如我们将在后面讨论的那样，angr 并没有总是使用 VEX 作为其 IR 的基本限制。在实现过程中，支持不同的中间表示法将是一项直接的工程工作。

> IR Lifter（Intermediate Representation Lifter）是一种软件工具或组件，用于将程序的低级别代码（如汇编语言或机器码）转换为高级别的中间表示（Intermediate Representation，IR）



*C. Submodule: Binary Loading*

将应用程序二进制文件加载到分析系统的任务由一个名为 CLE 的模块处理，CLE 是 CLE Loads Everything 的递归首字母缩写。CLE 对不同的二进制文件格式进行抽象，以处理加载给定的二进制文件及其依赖的任何库、解析动态符号、执行重定位以及正确初始化程序状态。通过 CLE，angr 支持来自大多数 POSIX 兼容系统（Linux、FreeBSD 等）、Windows 和为 DARPA 网络大挑战创建的 DECREE 操作系统的二进制文件。
CLE 为二进制加载器提供了一个可扩展的接口（以提供下列基类的方式），它提供了许多表示二进制对象（即应用程序二进制文件、POSIX .so 或 Windows .dll）、这些对象中的段和区块以及表示这些区块内位置的符号的基类。CLE 使用文件格式解析库（特别是用于 Linux 二进制文件的 elftools 和用于 Windows 二进制文件的 pefile）来解析对象本身，然后执行必要的重定位以显示加载应用程序的内存映像。



*D. Submodule: Program State Representation / Modification*

SimuVEX 模块负责表示程序状态（即寄存器和内存中的值快照、打开的文件等）。该状态在 SimuVEX 术语中被命名为 SimState，是作为状态插件的集合实现的，由用户指定的状态选项控制，或在创建状态时进行分析。目前有以下状态插件：
寄存器。SimuVEX 跟踪程序中任意给定点的寄存器值，作为相应程序状态的状态插件。
符号存储器（Symbolic memory）。为实现符号执行，SimuVEX 提供了符号内存模型作为状态插件。它实现了 Mayhem [16] 提出的索引内存模型。
抽象存储器（Abstract memory）。抽象内存状态插件用于静态分析，为内存建模。与实现连续索引内存模型的符号内存不同，抽象内存提供了一个基于区域的内存模型，被大多数静态分析所使用。
POSIX。在分析符合 POSIX 环境的二进制文件时，SimuVEX 会在此状态插件中跟踪系统状态。例如，这包括在符号状态下打开的文件。每个文件都表示为一个内存区域和一个符号位置索引。
日志。SimuVEX 在此插件中跟踪对状态所做的一切操作（如内存写入、文件读取等）的日志
检查。SimuVEX 提供了功能强大的调试界面，允许在复杂条件下设置断点，包括污点、精确表达式构成和符号条件。该接口还可用于更改 SimuVEX 的行为。例如，可以对内存读取进行检测，以模拟内存映射 I/O 设备
求解器。求解器是一个插件，可通过数据模型提供程序（Claripy，下文将讨论）为不同数据域提供接口。例如，当该插件配置为符号模式时，它会以符号方式解释寄存器、内存和文件中的数据，并在分析应用程序时跟踪路径限制。
架构。架构插件提供对分析有用的特定架构信息（如堆栈指针名称、架构字数等）。该插件中的信息来自 archinfo 模块，该模块也作为 angr 的一部分发布。

这些状态插件提供了可通过各种方式组合的构建模块，以支持不同的分析。
此外，SimuVEX 还实现了分析的基本单元：通过应用代码块（在 SimuVEX 术语中，这样的代码块称为 SimRun）来表示程序状态的语义变化。也就是说，SimuVEX 能够通过 VEX 表示的代码块处理输入状态，并生成输出状态（或一组输出状态，以防遇到可能有多个输出状态的代码块，如条件跳转）。同样，SimuVEX 的这一部分也是模块化的：除了基本程序块的 VEX 翻译之外，SimuVEX 目前还允许用户提供一个手工制作的 Python 函数作为 SimRun，从而为使用 Python 代码的程序块提供了一种强大的方法。事实上，这就是我们实现环境模型的方式：系统调用作为修改程序状态的 Python 函数来实现。



*E. Submodule: Data Model*

存储在 SimState 寄存器和内存中的值由另一个模块 Claripy 抽象表示。
Claripy 将所有值抽象为表达式的内部表示，并跟踪使用表达式的所有操作。也就是说，表达式 x 添加到表达式 5 后，将变成表达式 x + 5，并保持 x 和 5 作为其参数的链接。这些表达式以 "表达式树 "的形式表示，值为叶节点，操作为非叶节点。
在任何时候，表达式都可以转化为由 Claripy 后端提供的数据域。具体来说，Claripy 提供的后端支持具体域（整数和浮点数）、符号域（符号整数和符号浮点数，由 Z3 SMT 求解器提供 [25]）以及用于值集分析的值集抽象域 [6]。Claripy 可轻松扩展到其他后端。具体来说，实现其他 SMT 求解器会很有趣，因为有研究表明，不同的求解器擅长求解不同类型的约束 [8]。
面向用户的操作，例如将后端提供的构造（例如 Z3 后端提供的符号表达式 x+1）解释为 Python 基元（例如作为约束求解结果的 x + 1 的可能整数解），则由前端提供。前端通过不同复杂度的附加功能来增强后端。Claripy 目前提供多个前端：
FullFrontend 前端。该前端为用户提供符号求解、跟踪约束、使用 Z3 后端进行求解并缓存结果。
复合前端（CompositeFrontend）。正如 KLEE 和 Mayhem 所建议的那样，将约束条件拆分成独立的集可以减少求解器的负荷。CompositeFrontend 为这一功能提供了一个透明接口。
LightFrontend. 该前端不支持约束跟踪，只是使用 VSA 后端来解释 VSA 域中的表达式。
替换前端（ReplacementFrontend）。ReplacementFrontend 扩展了 LightFrontend，增加了对 VSA 值的约束支持。当引入一个约束条件（即 x+1 < 10）时，ReplacementFrontend 会对其进行分析，以确定相关变量的边界（即 0 <= x <=8）。随后，如果要查询变量 x 的可能值，ReplacementFrontend 会将变量与之前确定的范围相交，从而提供比 VSA 更精确的结果。
混合前端（HybridFrontend）。混合前端（HybridFrontend）结合了全前端（FullFrontend）和替换前端（ReplacementFrontend），为符号约束求解提供快速近似支持。虽然 Mayhem [16] 曾暗示过这种功能，但据我们所知，angr 是第一个向科研界提供这种功能的公开工具。
这种模块化设计允许 claripy 将各种数据域提供的功能以强大的方式结合起来，并将其暴露给 angr 的其他部分。



*F. Submodule: Full-Program Analysis*

angr 面向分析人员的部分提供完整的分析，如动态符号执行和控制流图恢复。项目（The Project，应该是一个类吧）是这些分析的 "入口"，代表一个二进制文件及其相关库。通过该对象，可以访问其他子模块的所有功能（即创建状态、检查共享对象、检索基本模块的中间表示、将二进制代码与 Python 函数挂钩等）。此外，还有两个主要接口用于全程序分析： 路径组和分析。
路径组（Path Group类）。路径组（PathGroup）是动态符号执行的接口——当路径在应用程序中运行、分支或终止时，它将对路径进行跟踪。该接口的创建源于对符号执行过程中路径管理的不满。在 angr 开发的早期，我们为每个使用符号执行的分析实现了路径的临时管理。我们发现自己正在重复实现相同的功能：跟踪路径分支和合并时的层次结构，分析哪些路径值得关注并应在探索中优先考虑，以及了解哪些路径没有前途并应终止。我们统一了对路径组的常见操作，创建了 PathGroup 接口。
分析（Analyses 类）。angr 通过分析类为任何完整的程序分析提供了一个抽象。该类管理静态分析（如控制流图恢复）和复杂动态分析（如第 IX 章所述）的生命周期。
当 angr 识别出二进制文件的某些真相（如 "地址 X 的基本块可以跳转到地址 Y 的基本块"）时，它会将其存储到相应项目的知识库中。通过这个共享知识库，各种分析可以协同发现有关应用程序的信息。



*G. Open-Source Release*

我们开始开发 angr 的目的是开发一个平台，在这个平台上我们可以实现新的二进制分析方法。当我们面对与现实二进制文件分析相关的意想不到的挑战时，我们意识到这样一个分析引擎对安全社区将非常有用。我们已将 angr 开源，希望它能为二进制分析的未来奠定基础，并将研究人员从重复解决相同难题的负担中解脱出来。angr 只用了 65,000 多行代码就实现了，可直接从 IPython shell 或作为 python 模块使用，并可通过标准 Python 包管理器 pip 轻松安装。
angr 的开源版本包括分析引擎模块（如第 VI-A 至 VI-F 节所述），我们在此基础上实现了第 XV 节讨论的应用。在后者中，我们开源了控制流图恢复、静态分析框架、动态符号执行引擎和欠约束符号执行实现。虽然我们计划在未来发布其他应用，但它们目前处于原型级代码和积极应用于 DARPA 网络大挑战的混合状态。
angr受到了社区的极大欢迎。在开源发布后的头三个月，我们在 GitHub 上收集了近 500 个 "星级"（衡量人们对软件评价的标准），涉及构成系统的不同模块。在同一时期，angr 通过 pip 共安装了约 6000 次，每周平均有 20 次 "克隆 "Git 仓库。angr 已在另一所院校的至少一个课堂项目中使用，向学生们介绍二进制分析。此外，我们还了解到其他一些机构将其作为构建研究原型的基础，还有一些公司正在评估它在商业二进制分析系统中的可用性。

### VII. IMPLEMENTATION: CFG RECOVERY

我们将介绍 angr 生成 CFG 的过程，包括为提高最终结果的完整性和合理性（Soundness）而开发的特定技术。
给定一个特定的程序，angr 会从程序的入口点开始执行迭代 CFG 恢复，并进行一些必要的优化。angr 综合利用强制执行、反向切片和符号执行，尽可能恢复每个间接跳转的所有跳转目标。此外，它还生成并存储了大量有关目标程序的数据，这些数据可用于以后的其他分析，如数据依赖性跟踪。

这种算法有三个主要缺点：速度慢，不能自动处理 "死代码"，可能会漏掉只能通过未恢复的间接跳转才能到达的代码。为了解决这个问题，我们创建了一种辅助算法，使用快速反汇编二进制代码（不执行任何基本代码块），然后使用启发式方法识别函数、函数内控制流和直接函数间控制流转换。然而，二级算法的准确性要差得多--它缺乏函数间可达性的信息，对上下文不敏感，而且无法恢复复杂的间接跳转。
在本节的提醒部分，我们将讨论我们的高级恢复算法，我们称之为 CFGAccurate。然后，我们将在第 VII-F 节讨论我们的快速算法 CFGFast。



*A. Assumptions*

为了优化算法的运行时间，angr 的 CFGAccurate 对二进制文件做了几个假设。
1) 程序中的所有代码都可以分配到不同的函数中。
2) 在控制流中，所有函数要么通过明确的调用指令（或等价指令）进行调用，要么在调用之前进行尾跳转（这是一种优化，通常用于减少递归函数的栈空间，即把函数最末端的调用改为跳转，这样新调用的函数就可以简单地重复使用其调用者的返回地址）。
3) 无论从何处调用，每个函数的堆栈清理行为都是可预测的。这使得 CFGAccurate 在分析调用者函数时，可以安全地跳过已经分析过的函数，并保持堆栈平衡。

这些假设对 angr 设计用于分析的二进制文件类型施加了限制。假设 1、2 和 3 要求被分析的二进制文件没有被混淆，并且行为 "正常"。在分析混淆或异常二进制文件时，我们可以取消这些假设，但这会导致 CFG 恢复的运行时间增加。我们的 CFG 恢复代码建立在相关文献[21]、[34]、[50]、[58]、[59]提出的技术基础之上。不过，这些技术的假设过于严格，或者对现实世界的二进制文件来说不切实际。具体来说，与我们的 CFG 恢复所基于的工作不同，我们不假设以下任何情况：

1) 所有函数都返回到其调用位置后的下一条指令[59]。
2) 间接分支的跳转目标总是由控制流路径决定，而不是由程序状态或上下文决定 [59]。例如，现有的一些文献假定间接跳转都是计算出来的，而不是从先前的上下文中作为函数指针传入的。
3) 间接跳转的跳转目标表达式必须与一组常用惯用语相匹配 [21], [58]。与现有工作不同的是，我们对可应用于指针的操作类型不做任何假设。
4) 堆栈指针在进入函数之前和返回函数之后是一样的。
5) 没有两个函数重叠（换句话说，它们不能共享基本块 [34]）。CFGAccurate 会处理共享代码的函数。
6) 提供附加信息，如符号表或重定位信息[50]。

下面几节将介绍从二进制文件中恢复控制流图的实际算法。



*B. Iterative CFG Generation*

遗憾的是，没有一种单一的技术能满足 CFGAccurate 恢复完整和健全 CFG 的目标。因此，CFGAccurate 通过交错使用一系列技术来构建 CFG，以实现速度和完整性。具体来说，它使用了四种技术：强制执行、轻量级后向切片、符号执行和值集分析。通过这些技术迭代恢复的 CFG，即 C，在应用程序的入口点以基本块初始化。

在整个 CFG 恢复过程中，CFGAccurate 会维护一个间接跳转列表 Lj，其跳转目标尚未被解析。当分析发现此类跳转时，就会将其添加到 Lj 中。每个迭代技术结束后，CFGAccurate 会触发列表中的下一个技术。下一个技术可能会解析 Lj 中的跳转，可能会在 Lj 中添加新的未解析跳转，可能会在 CFG C 中添加基本块和边。当所有技术的运行结果都没有改变 Lj 或 C 时，CFGAccurate 将终止，因为这意味着任何可用的分析都无法解析更多的间接跳转。



*C. Forced Execution*

> "强制执行"（Dynamic Forced Execution）是指通过在程序运行时，强制执行特定的代码路径或指令序列，以触发特定的程序行为或漏洞。

angr 的 CFGAccurate 在 CFG 恢复的第一阶段利用了动态强制执行的概念 [59]。强制执行确保在每个分支点都执行条件分支的两个方向。
CFGAccurate 维护一个基本区块工作列表 Bw 和一个分析区块列表 Ba。分析开始时，它会用 C 中但不在 Ba 中的所有基本程序块初始化其工作列表。每当 CFGAccurate 从工作列表中分析一个基本程序块时，该基本程序块和来自该程序块的任何直接跳转都会被添加到 C 中。 
但是，间接跳转不能这样处理。在强制执行情况下，间接跳转的目标可能与程序实际运行时的目标不同，因为强制执行会以意想不到的顺序执行代码。因此，每个间接跳转都会存储在列表 Lj 中，以便日后分析。
由于无法解析任何间接跳转，该分析可作为快速 CFG 恢复分析，利用检测到的基本程序块和未解析的间接跳转快速为其他分析提供种子。



*D. Symbolic Execution*

动态强制执行的主要问题是存在间接跳转，因为无法确保间接跳转的目标被正确解析。一方面，间接跳转可能完全无法解析（即强制执行的结果是跳转目标从未初始化的内存中读取），这会在恢复的 CFG 中留下中断的控制流转换。另一方面，间接跳转也可能是部分可解的（即我们的分析只检索到所有可能的跳转目标中的一部分）。

对于每个跳转 J∈Lj ，CFGAccurate 都会反向遍历 CFG，直到找到第一个合并点（即多条路径在通往间接跳转的途中汇合）或达到阈值块数（根据经验，我们发现合理的阈值为 8）。然后，它执行前向符号执行到间接跳转点，并使用约束求解器检索间接跳转目标的可能值。

如果计算出的可能目标集合小于阈值大小，CFGAccurate 就会认为跳转已成功解析。我们使用的阈值为 256，但在实践中我们发现，在跳转未成功解决的情况下，该值是无约束的（也就是说，可能目标的集合仅受地址位数的限制）。
如果跳转成功解决，则从 Lj 中删除 J，并为跳转目标的每个可能值在 CFG 中添加边和节点。

> 在这个上下文中，"unconstrained"（无约束的）指的是没有受到限制或限定。在给定的句子中，它指的是在某些情况下，跳转指令的可能目标没有受到特定的大小限制。具体地说，在这个情况下，跳转指令的可能目标受到地址位数的限制，而没有受到特定阈值（256）的约束。也就是说，在这些情况下，计算出的可能目标集合可以非常大，可能包含了整个地址空间的所有可能地址，而不受到具体大小限制。



*E. Backward Slicing*

由于缺乏上下文，angr 的强制执行和符号执行分析无法解析许多未解析的跳转。这些分析是以对上下文不敏感的方式进行的：如果一个函数将指针作为参数，而该指针被用作间接跳转的目标，那么这些分析将无法解析它。

为了实现更好的完整性，我们的 CFG 生成需要一个上下文敏感组件。我们通过后向切分来实现这一点。CFGAccurate 从未决跳转开始计算后向切片。该切片从上一个调用上下文的起点开始延伸。也就是说，如果被分析的间接跳转位于函数 Fa 中，而函数 Fa 同时被 Fb 和 Fc 调用，那么切片将从 Fa 中的跳转向后延伸，并包含两个起始节点：位于 Fb 起始处的基本模块和位于 Fc 起始处的基本模块。

然后，CFGAccurate 使用 angr 的符号执行引擎执行该切片，并使用约束引擎识别符号跳转的可能目标，跳转目标的解集大小阈值同样为 256。如果成功解决了跳转目标，就会从 Lj 中删除跳转并将代表控制流转换的边，和目标基本模块添加到恢复的 CFG 中。



*F. CFGFast*

快速 CFG 生成算法的目标是生成一个具有高代码覆盖率的图形，至少能识别二进制文件中函数的位置和内容。该图缺少大部分控制流，因此并不完整。不过，这样的图形对于二进制文件的手动和自动分析仍然很有用。

CFGFast 执行以下步骤：

函数识别。我们使用硬编码的函数序言签名（可通过 ByteWeight [7] 等技术生成）来识别应用程序内部的函数。如果应用程序中包含指定函数位置的符号，我们也会使用这些符号为图提供函数起始位置的种子。此外，代表程序入口点的基本块也会添加到图中。

递归反汇编。递归反汇编用于恢复已识别函数中的直接跳转。

间接跳转解析。轻量级别名分析、数据流跟踪与预定义策略相结合，用于解决函数内控制流转移问题。目前，CFGFast 包括跳转表识别和间接调用目标解决策略。

CFGFast 的目标是快速恢复具有高覆盖率的 CFG，而无需了解函数之间的可达性。



*G. Using the CFG Recovery*

angr 将 CFG 恢复算法公开为两种分析： CFGFast 和 CFGAccurate。这些分析将 CFG 数据输出到 angr 的知识库中， 如第 VI-F 节所述。这些数据可以在手动分析或后续自动分析过程中使用。
